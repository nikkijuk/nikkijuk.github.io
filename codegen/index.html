<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<textarea data-template>
#### Codegen 2.0 / Collaboration with AI

“I believe the hard part of building software to be the specification, design,
and testing of this conceptual construct, not the labor of representing it
and testing the fidelity of the representation."
― Frederick P. Brooks Jr.

“Conceptual integrity does require that a system reflect a single philosophy
and that the specification as seen by the user flow from a few minds."
― Frederick P. Brooks Jr.

        // Name: Jukka Nikki, Identity: Programmer
        // Goal: Find the last bug, Since: 6502

					</textarea>
				</section>


                <section data-markdown>
					<textarea data-template>
#### Codegen 1.0 / Rules & templates

- code from model (MDD,  Model driven development, e.g. Enterprise Architect, IBM Rhapsody)
- code from architecture (MDA, Model driven architecture, e.g. ArchiMate)
- code from domain-specific language, often custom syntax (external DSL, e.g. Xtext, JetBrains MPS)

Deterministic, mature, but limited adoption.
Tools either proprietary or not feasible for general use (learning curve, license costs).
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>

#### Codegen 2.0 / AI-assisted development

- Assistants (e.g. Github CoPilot, OpenAI Codex, Google Gemini, Jetbrains AI)
- Prototype generators (e.g. Figma Make, Miro AI, v0)
- Toolsets (e.g. Google Antigravity, Kilo AI, Roo-Code, Claude Code)
- Code from spec (e.g. GitHub SpecKit, AWS Kiro, Tessl Framework, Gemini Cli with Conductor)

Tools are emerging rapidly, but still experimental. No standard practices.
Same challenges as in traditional coding (quality, security, maintainability, ..)
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### Codegen 1.0 & 2.0 synergy

- Codegen 1.0 can generate boilerplate code as well as Codegen 2.0 inputs.
- Codegen 2.0 can transform Codegen 1.0 outputs and orchestrate codegen 1.0 tools usage.

It's possible to combine both approaches for better results.
Custom MCP servers can be created to wrap Codegen 1.0 tools,
for example with Jetbrains Koog.ai.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [AI coding evolution](https://medium.com/aimonks/ai-coding-from-code-completion-to-knowledge-alignment-6d4c5a8ee669)

<img alt="nc 1990" src="images/ai-code-evolution.png" width="60%">

- Code completion (IDE plugins)
- Prompt engineering (within IDE)
- Monolithic generation (Vibe coding)
- Context-aware generation (agents.md)
- AI Pair programming (Plan mode)
- Spec-driven development (SDD)
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### AI autonomy levels

<img alt="nc 1990" src="images/ai_autonomy.png" width="100%">

"Human" (None) to "Superbrain" (All) scale for AI tools.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### Measuring AI impact / Study results

"Code written with AI assistance was no
harder to change, no easier to change,
no worse in quality and no better in
quality. From a downstream perspective,
AI didn't break anything.
(..)
AI users were
about 30% faster to get to a solution.
(..)
Habitual AI users were closer to
55% faster.
(..)
AI tends to produce boring, idiomatic,
unsurprising code. And boring code is
good.
(..)
As always tools matter,
but how we use them matters more.
" - Dave Farley
					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [Context Engineering: Tactical vs. Strategic](https://intent-driven.dev/knowledge/plan-mode-vs-sdd/)

Tactical context engineering (Plan Mode) focuses on immediate task context,
while strategic context engineering (Spec Driven) builds long-term knowledge structures.

Plan mode is supposed to fit better for greenfield solo projects,
whereas SDD is better for team projects with evolving requirements.

                    </textarea>
                </section>


                <section data-markdown>
					<textarea data-template>
#### [Creating Context: Claude code](https://www.eesel.ai/blog/claude-ai-coding-assistant)

<img alt="nc 1990" src="images/claude-context.png" width="60%">

- Whole codebase as main context
- Instruction files (e.g. Claude.md) as guidelines.
- MCP servers integrate external data sources.

External sources can be specifications, task descriptions, ui mockups, ..
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [Plan Mode: Claude code](https://www.eesel.ai/blog/claude-ai-coding-assistant)

<img alt="nc 1990" src="images/explore-plan-code-commit.png" width="60%">

- Collect context from relevant sources
- Create plan, refine until accepted by developer
- Generate code and run tests based on plan
- Review and commit results to codebase

Structured approach saves time and improves quality as
intent is clarified before code generation.
Pair programming: AI is driver, developer is navigator.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>

#### [Spec-Driven Development (SDD)](https://www.infoq.com/articles/spec-driven-development/)

<img alt="nc 1990" src="images/spec-flow.png" width="100%">

["Spec-driven development means writing a “spec” before writing code with AI.
The spec becomes the source of truth for the human and the AI."](https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html)

Spec has aspects like architecture, domain models, requirements,
and is refined over time.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>

#### [Specification over code](https://www.infoq.com/articles/spec-driven-development/)

SDD represents a fundamental shift in how software systems are architected, governed, and evolved.

At a technical level, it introduces a declarative, contract-centric control plane that repositions
the specification as the system's primary executable artifact.

Implementation code, in contrast, becomes a secondary, generated representation of architectural intent.

                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [Code is king vs. specs rule](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

<img alt="nc 1990" src="images/sdd_vs_classical_model.png" width="80%">

For decades, software architecture has operated under a largely unchallenged assumption
that code is the ultimate authority
=> Result: Architecture drift, technical debt, misalignment with business goals.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
### [SDD Use-cases](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

<img alt="nc 1990" src="images/sdd-usecases.png" width="80%">

- new, renew (code=>spec, spec=>code), or re-architect systems.
- role of developers changes from code writers to system architects.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
### [SDD Levels](https://martinfowler.com/articles/exploring-gen-ai/sdd-3-tools.html)

- Spec-first: A well thought-out spec is written first, and then used in the AI-assisted development workflow for the task at hand.
- Spec-anchored: The spec is kept even after the task is complete, to continue using it for evolution and maintenance of the respective feature.
- Spec-as-source: The spec is the main source file over time, and only the spec is edited by the human, the human never touches the code.
					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### Generating once is nice, but not enough

<img alt="nc 1990" src="images/sdd-levels.png" width="80%">

- Quality of results rely on input spec quality.
- Level defines process AI tool is able to support.
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [SDD Context: Specs & Memory banks](https://www.geocod.io/code-and-coordinates/2026-01-21-hand-chiseling-code/)

<img alt="nc 1990" src="images/sdd-overview.png" width="60%">

- Memory bank stores shared definitions.
- Specs store feature-specific definitions.
- Together they create context for code generation.

                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [Context / Layer / responsibility](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

<img alt="nc 1990" src="images/ai_asset_governance.png" width="75%">

Governance of context by responsibility area / role.

					</textarea>
                </section>


                <section data-markdown>
					<textarea data-template>
#### [AI project Tasks / time spent](https://www.geocod.io/code-and-coordinates/2026-01-21-hand-chiseling-code/)

<img alt="nc 1990" src="images/sdd-time-division.jpeg" width="60%">

- Spec / Prompt is continuously refined. Code is mostly byproduct, which needs to be reviewed.
- Work content changes and adapts. Required skill combination might be rather uncommon.
- New roles emerge (spec architect, spec engineer, ..). There might be scaling bottlenecks (skill shortage).

                    </textarea>
                </section>

				<section data-markdown>
					<textarea data-template>
				### [SDD is non-deterministic](https://www.thoughtworks.com/en-de/insights/blog/agile-engineering-practices/spec-driven-development-unpacking-2025-new-engineering-practices)

"Spec drift and hallucination are inherently difficult to avoid.
We still need highly deterministic CI/CD practices to ensure software quality
and safeguard our architectures." - Liu Shangqi

None of the current best practices like unit tests, CI/CD pipelines,
Linting, autoformatting, modular architecture, code reviews, etc.
are outdated by SDD. They are more important than ever.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
				#### [SDD Workflow](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

				<img alt="nc 1990" src="images/sdd-workflow.png" width="55%">

there’s a lack of consensus on the ‘correct’ spec-driven development workflow and what exactly a good spec should look like in the context of AI-assisted coding.
					</textarea>
				</section>

                <section data-markdown>
					<textarea data-template>
#### [when the spec becomes the primary artifact](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

- Every developer needs to think like an architect.
- Organizations must adapt operationally.
- Architectural clarity must be prioritized.
- Teams need training to build specification literacy.

Writing or refining specifications requires the same level of systems thinking
that was once limited to senior technical roles.
					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### [SDD and Double diamond]()

<img alt="nc 1990" src="images/double-diamond_2.png" width="40%">

- Spec can be created at product discovery.
- Define can produce working generated prototype.
- Develop and deliver refine prototype to product.

Reverse double diamond:
create working solution first, then start research and collect insights.
					</textarea>
                </section>

				<section data-markdown>
					<textarea data-template>
				#### [SDD Hypothesis](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

Businesses that rely solely on AI-generated code without structured specs
accumulate hallucinated logic, inconsistent patterns, and unpredictable failures.

But those that adopt SDD will shift from code ownership –
where engineers fight to keep implementations aligned to intent ownership –
where specifications drive the entire lifecycle.
					</textarea>
				</section>

                <section data-markdown>
					<textarea data-template>
				#### [Thoughtworks Techradar: Assess](https://www.corporate-rebels.com/blog/right-kind-of-wrong-intelligent-failure)

				<img alt="nc 1990" src="images/sdd-techradar-2.png" width="100%">

"We find this space fascinating, though the workflows remain elaborate and opinionated." - Thoughtworks
                    </textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
				#### [Recommendation: Experiment & fail cleverly](https://www.corporate-rebels.com/blog/right-kind-of-wrong-intelligent-failure)

				<img alt="nc 1990" src="images/intelligent-failure.png" width="40%">

"It’s impossible to calculate the wasted time and resources created by our reluctance
to take the smart risks that lead to progress." - Amy Edmondson
					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
					### Challenges

- SDD requires cultural change and shifts power dynamics in teams and organizations.
- Collaboration with non-technical stakeholders is essential, coder alone cannot deliver.
- Caps in specs coverage and quality are detected early, not at the end of development.
- Tooling and processes are immature and evolving rapidly, requiring continuous learning.
- Existing codebases may not be suitable for SDD adoption, and first projects may be risky.
					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
					#### SDD adoption: Start here.

- New greenfield projects without legacy constraints.
- Well-defined domains with clear requirements.
- Teams open to experimentation and new practices.
- Modular architecture for incremental adoption.
- Typed, nullsafe, garbage collected language.
- Controls like automated build pipeline.
					</textarea>
                </section>

				<section data-markdown>
					<textarea data-template>
					### Summary

- Spec-driven development (SDD) uses AI to generate code from structured specifications.
- Role of developer shifts from code to describe intent and architecture in specs.
- SDD can improve code quality, maintainability, and alignment with business goals.
- Successful adoption of SDD requires new workflows, tools, and mindsets.
- SDD does not work on all projects equally well. Careful experimentation is needed.
					</textarea>
				</section>

                <section data-markdown>
					<textarea data-template>
#### Final thoughts

“Remember that code is really the language in which we ultimately express
the requirements. We may create languages that are closer to the requirements.
We may create tools that help us parse and assemble those requirements
into formal structures. But we will never eliminate necessary precision —
so there will always be code.”
― Robert C. Martin


					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### Sloppy inputs => AI slop

<img alt="nc 1990" src="images/gigo_1.png" width="40%">

["On two occasions I have been asked, "Pray, Mr. Babbage, if you put into the machine wrong figures,
will the right answers come out?" ...
I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."](https://en.wikipedia.org/wiki/Garbage_in,_garbage_out)
— Charles Babbage
					</textarea>
                </section>
                <section data-markdown>
					<textarea data-template>
#### [AI assets / responsibility](https://www.nitorinfotech.com/blog/spec-driven-development-explained/)

<img alt="nc 1990" src="images/ai_asset_governance.png" width="70%">

Assets for context can be organized by responsibility areas:

- Business (e.g. requirements, user stories, acceptance criteria)
- Domain (e.g. domain models, ubiquitous language, glossary)
- Technical (e.g. architecture diagrams, design patterns, coding standards)
					</textarea>
                </section>

                <section data-markdown>
					<textarea data-template>
#### DISCLAIMER

“Life can only be understood backwards; but it must be lived forwards.”
― Søren Kierkegaard

- To understand AI one needs to experiment ..
- Experimenting means failing well for a goal ..
- Failures should be small, backed by hypothesis ..
- Each experiment teaches something new ..
- And prepares you for next experiment ..
                    </textarea>
                </section>

				</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
