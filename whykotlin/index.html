<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<textarea data-template>
				### Why kotlin?

				"Programs must be written for people to read, and only incidentally for machines to execute." —Harold Abelson, Structure and Interpretation of Computer Programs

				Jukka Nikki, Java Programmer

				Java SE 8 Programmer (2015),
				Java EE 5 Enterprise Architect (2011),
				Java SE 7 Programmer (2011),
				Java EE 6 Java Persistence API Developer (2010),
				Java EE 6 Web Services Developer (2010),
				Sun Certified Web Component Developer (2003),
				Sun Certified Java 1.4 Programmer (2002)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
				## why does programming language matter
				- concise?, or expressive?
				-	right defaults?, or safer?
				- rich programming models?
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						## Clarity
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
				"The simpler and more concise the code is, the faster you’ll understand what’s going on. Of course, good design and expressive names play a significant role here. But the choice of the language and its conciseness are also important. The language is concise if its syntax clearly expresses the intent of the code you read and doesn’t obscure it with boilerplate required to specify how the intent is accomplished."

				[Dmitry Jemerov and Svetlana Isakova, "Kotlin in Action"](https://www.manning.com/books/kotlin-in-action)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						## Safety
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						"And then I went and invented the null pointer. You either have to check every reference, or you risk disaster"

						"what would be a significant improvement would be to make all variables not-null by default. Then, when a programmer decides that they want to use a null reference, they can opt-in to using a nullable type as opposed to opting-out of nullable types in cases where they either do not need or want nullable types."

						[Tony Hoare](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/)

					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Null safe languages

						- Eiffel
						- Spec#
						- F#
						- C#
						- Kotlin
						- Dart
						- Swift

						https://en.wikipedia.org/wiki/Void_safety
					</textarea>
				</section>
				</section>
				<section data-markdown>
					<textarea data-template>
				"Int is said to be a non-nullable type, whereas Int? is a nullable type. Kotlin uses this mechanism for all types, which exist in two versions: nullable (postfixed with a ?) and non-nullable. The most interesting part of the story is that any non-nullable type is a child type of the corresponding nullable type"

				[Pierre-Yves Saumont, "The Joy of Kotlin"](https://www.manning.com/books/the-joy-of-kotlin)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
					following is correct:

							val x: Int = 3
							val y: Int? = x

					But this is not:

							val x: Int? = 3
							val y: Int = x

					[Pierre-Yves Saumont, "The Joy of Kotlin"](https://www.manning.com/books/the-joy-of-kotlin)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
					"Kotlin has no primitives, at least not at the programmer level. Instead, it uses Java primitives under the hood to make computation faster. But you, as the programmer, will only be manipulating objects. The object class for integers is different than the object representation of integers in Java. Instead of Integer, you’ll use the Int class."

					[Pierre-Yves Saumont, "The Joy of Kotlin"](https://www.manning.com/books/the-joy-of-kotlin)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						## Programming models
					</textarea>
				</section>
				</section>
				<section data-markdown>
					<textarea data-template>
				#### Programming paradigms

				imperative
				- procedural, groups instructions into procedures
				- object-oriented, groups instructions with state they operate on

				declarative
				- functional, result is value of a series of functions
				- reactive, result is propagation of change of data streams

				https://en.wikipedia.org/wiki/Programming_paradigm

					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
				## My learning path
				| Language    | Culture               |
				| ----------- | --------------------- |
				| Basic (84), 6502/68000 assembler (85/86), Cobol (89), Turbo Pascal (89), C (91), SQL, PL/SQL, PHP, Python, .. | Procedural |
				| C++ (91), Delphi (95), Java (97), Groovy, Xtend, JS, .. | Object oriented |
				| Scala (2013), TS (2018), Kotlin (2018), .. | OOP & Functional |
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
				""Should you use Java for functional programming”? Surprisingly (given the subject of this book) the answer is no. With the freedom to choose any language, I’ll say that you shouldn’t chose Java for this purpose. But you generally won’t have this freedom."

				[Pierre-Yves Saumont, preface of "Functional Programming in Java"](https://www.manning.com/books/functional-programming-in-java)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
				"Kotlin was designed to be much friendlier towards many techniques coming from functional programming. Kotlin has both mutable and immutable references, but it heavily promotes immutable ones. Kotlin also has a great part of the functional abstractions that let you avoid control structures."

				[Pierre-Yves Saumont, preface of "The Joy of Kotlin"](https://www.manning.com/books/the-joy-of-kotlin)
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
				![paradigms](images/kotlin_paradigms.png)

				"Some languages tell you how you should write code. Kotlin isn’t one of those. With Kotlin, you decide which paradigm works best for the application at hand. "

				[Venkat Subramaniam, "Programming Kotlin"](https://pragprog.com/titles/vskotlin/programming-kotlin/)
					</textarea>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
